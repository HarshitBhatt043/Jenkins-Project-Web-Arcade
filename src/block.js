import{getMoveDownValue,getLandBlockVelocity,getSwingBlockVelocity,touchEventHandler,addSuccessCount,addFailedCount,addScore}from"./utils";import*as constant from"./constant";const checkCollision=(t,e)=>t.y+t.height>=e.y?t.x<e.x-t.calWidth||t.x>e.collisionX+t.calWidth?1:t.x<e.x?2:t.x>e.collisionX?3:t.x>e.x+.8*t.calWidth&&t.x<e.x+1.2*t.calWidth?5:4:0,swing=(t,e,a)=>{const o=e.getVariable(constant.ropeHeight);if(t.status!==constant.swing)return;const n=t,s=e.getVariable(constant.initialAngle);n.angle=s*getSwingBlockVelocity(e,a),n.weightX=n.x+Math.sin(n.angle)*o,n.weightY=n.y+Math.cos(n.angle)*o},checkBlockOut=(t,e)=>{t.status===constant.rotateLeft?t.y-t.width>=e.height&&(t.visible=!1,t.status=constant.out,addFailedCount(e)):t.y>=e.height&&(t.visible=!1,t.status=constant.out,addFailedCount(e))};export const blockAction=(t,e,a)=>{const o=t,n=e.getVariable(constant.ropeHeight);if(!o.visible)return;o.ready||(o.ready=!0,o.status=constant.swing,t.updateWidth(e.getVariable(constant.blockWidth)),t.updateHeight(e.getVariable(constant.blockHeight)),t.x=e.width/2,t.y=-1.5*n);const s=e.getInstance("line");switch(o.status){case constant.swing:e.getTimeMovement(constant.hookDownMovement,[[t.y,t.y+n]],(e=>{t.y=e}),{name:"block"}),swing(t,e,a);break;case constant.beforeDrop:o.x=t.weightX-t.calWidth,o.y=t.weightY+.3*t.height,o.rotate=0,o.ay=e.pixelsPerFrame(3e-4*e.height),o.startDropTime=a,o.status=constant.drop;break;case constant.drop:const c=a-o.startDropTime;o.startDropTime=a,o.vy+=o.ay*c,o.y+=o.vy*c+.5*o.ay*c**2;const i=checkCollision(t,s),r=s.y-t.height,l=t=>{t.originOutwardAngle=Math.atan(t.height/t.outwardOffset),t.originHypotenuse=Math.sqrt(t.height**2+t.outwardOffset**2),e.playAudio("rotate")};switch(i){case 1:checkBlockOut(t,e);break;case 2:o.status=constant.rotateLeft,t.y=r,t.outwardOffset=s.x+t.calWidth-t.x,l(t);break;case 3:o.status=constant.rotateRight,t.y=r,t.outwardOffset=s.collisionX+t.calWidth-t.x,l(t);break;case 4:case 5:o.status=constant.land;const a=e.getVariable(constant.successCount);addSuccessCount(e),e.setTimeMovement(constant.moveDownMovement,500),10!==a&&15!==a||e.setTimeMovement(constant.lightningMovement,150),t.y=r,s.y=r,s.x=o.x-o.calWidth,s.collisionX=s.x+o.width;const n=.3*o.width;(o.x>e.width-2*n||o.x<-n)&&e.setVariable(constant.hardMode,!0),5===i?(t.perfect=!0,addScore(e,!0),e.playAudio("drop-perfect")):(addScore(e),e.playAudio("drop"));break;default:break}break;case constant.land:e.getTimeMovement(constant.moveDownMovement,[[t.y,t.y+getMoveDownValue(e,{pixelsPerFrame:t=>t/2})]],(a=>{t.visible&&(t.y=a,t.y>e.height&&(t.visible=!1))}),{name:t.name}),t.x+=getLandBlockVelocity(e,a);break;case constant.rotateLeft:case constant.rotateRight:const d=o.status===constant.rotateRight,h=e.pixelsPerFrame(4*Math.PI),g=d?1:-1;if(d?t.rotate>1.3:t.rotate<-1.3)t.rotate+=h/8*g,t.y+=e.pixelsPerFrame(.7*e.height),t.x+=e.pixelsPerFrame(.3*e.width)*g;else{let e=(t.calWidth-t.outwardOffset)/t.calWidth;e=e>.5?e:.5,t.rotate+=h*e*g;const a=t.originOutwardAngle+t.rotate,o=d?s.collisionX+t.calWidth:s.x+t.calWidth,n=s.y;t.x=o-Math.cos(a)*t.originHypotenuse,t.y=n-Math.sin(a)*t.originHypotenuse}checkBlockOut(t,e);break;default:break}};const drawSwingBlock=(t,e)=>{const a=e.getImg("blockRope");e.ctx.drawImage(a,t.weightX-t.calWidth,t.weightY,t.width,1.3*t.height);const o=t.weightX-t.calWidth;e.debugLineY(o)},drawBlock=(t,e)=>{const{perfect:a}=t,o=e.getImg(a?"block-perfect":"block");e.ctx.drawImage(o,t.x,t.y,t.width,t.height)},drawRotatedBlock=(t,e)=>{const{ctx:a}=e;a.save(),a.translate(t.x,t.y),a.rotate(t.rotate),a.translate(-t.x,-t.y),drawBlock(t,e),a.restore()};export const blockPainter=(t,e)=>{const{status:a}=t;switch(a){case constant.swing:drawSwingBlock(t,e);break;case constant.drop:case constant.land:drawBlock(t,e);break;case constant.rotateLeft:case constant.rotateRight:drawRotatedBlock(t,e);break;default:break}};